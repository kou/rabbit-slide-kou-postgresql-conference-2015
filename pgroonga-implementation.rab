= PGroongaの実装

: subtitle
   (('note:ぴーじーるんがのじっそう'))
: author
   須藤功平
: institution
   クリアコード
: content-source
   PostgreSQLカンファレンス2015
: date
   2015-11-27
: allotted-time
   40m
: theme
   .

= （建前の）目的

PostgreSQLのamindexを説明

= 方法

PGroongaの実装を紹介\n
(('note:（PGroongaはamindexとして実装されているため）'))

= 本当の目的

PGroongaの自慢

= PGroongaとは

amindexの一種

= amindex

索引の実装を\n
PostgreSQLに\n
追加する仕組み

= amindexの使い方

  # coderay sql
  CREATE INDEX name ON table
    USING pgroonga (column);

(('tag:center'))
組み込みの索引と同じ\n
（(({USING}))を指定するだけ）

= PGroongaの提供機能

索引を使った\n
((*超高速な*))\n
全文検索機能

= PostgreSQLと全文検索

課題あり

= PostgreSQLと全文検索1

  # coderay sql
  CREATE INDEX name ON table
    USING gin (to_tsvector('english', column));
  SELECT * FROM table
    WHERE to_tsvector('english', column) @@ '...';

(('tag:center'))
組み込み機能を使う\n
日本語非対応\n
(('note:http://www.postgresql.org/docs/current/static/textsearch.html'))

= PostgreSQLと全文検索2

  # coderay sql
  CREATE INDEX name ON table
    USING gin (column gin_trgm_ops);
  SELECT * FROM table
    WHERE column % '...';

(('tag:center'))
contrib/pg_trgmを使う\n
日本語非対応\n
(('note:http://www.postgresql.org/docs/current/static/pgtrgm.html'))

= PostgreSQLと全文検索

日本語非対応

= PGroongaとPostgreSQL

日本語対応！

= PGroongaを使う

  # coderay sql
  CREATE INDEX name ON table
    USING pgroonga (column);
  SELECT * FROM table
    WHERE column @@ '全文検索';

(('tag:center'))
日本語対応！

= しかも速い！

= ヒット数と検索時間

  # RT
  delimiter = [|]

  ヒット数 | 検索時間

  368 | 0.030s(('   '))
  17,172 | 0.121s(('   '))
  22,885 | 0.179s(('   '))
  625,792 | 0.646s(*)

(('note:(*) work_memを10MBに増やしている'))

(('tag:center'))
データ：Wikipedia日本語版\n
(('note:約184万レコード・平均サイズ約3.8KB'))

= 検索時間：比較

  # RT
  delimiter = [|]

  ヒット数 | PGroonga | pg_bigm

  368 | 0.030s(!) | 0.107s(('   '))
  17,172 | 0.121s(!) | 1.224s(('   '))
  22,885 | 0.179s(!) | 2.472s(('   '))
  625,792(*) | 0.646s(('   ')) | 0.556s(!)

(('note:(*) 他は検索語が3文字以上でこれだけ2文字'))

(('tag:center'))
PGroongaは安定して速い！

= なぜ速いのか

バックエンドが\n
外部の本格的な\n
全文検索\n
ライブラリー

= amindexでのポイント

  * (({_PG_init()}))
    * ライブラリーを初期化
  * (({on_proc_exit()}))
    * 後始末

= 全文検索ライブラリー

Groonga

= Groonga

((*本格的な*))\n
全文検索\n
エンジン\n
(('note:サーバーとしてもライブラリーとしても使える'))

= 本格的な例1

(('tag:center'))
長い文書でも検索性能が落ちない

この特徴が有用なサービス例：

  * Wiki
    * イメージ：Wikipedia
  * ドキュメント検索
    * イメージ：ファイルサーバー検索

= 長い文書でも速い理由

((*完全*))\n
転置索引

= 転置索引

  * 完全：位置情報あり
    * Groonga
  * 無印：位置情報なし
    * GIN

= 転置索引の違い

  # image
  # src = images/inverted-index.svg
  # relative_height = 100

= 索引での検索の違い

  # image
  # src = images/search-with-inverted-index.svg
  # relative_height = 100

= 検索速度の違い

  * 完全転置索引：安定して速い
    * 索引だけで検索完了
  * 転置索引：速さが安定しない
    * 索引での検索+全件スキャン
    * 候補文書が多い・長い→遅くなる

= amindexでのポイント

  * 全件スキャンを無効にする
    * (({scan->xs_recheck = false}))
    * (({tbm_add_tuples(..., false)}))

= 本格的な例2

(('tag:center'))
常時更新・常時検索に強い

この特徴が有用なサービス例：

  * SNS
    * イメージ：Twitter
  * ナレッジ共有サービス
    * イメージ：Qiita・teratail

= 常時更新・検索に強い？

更新中も\n
参照性能が\n
落ちない

= 落ちない理由

更新時に\n
参照ロックなし

= 参照ロック

獲得したら\n
他の処理は\n
参照不可になる\n
ロック

= GINと更新と参照

  # image
  # src = images/read-while-write-gin.svg
  # relative_height = 95

= Groongaと更新と参照

  # image
  # src = images/read-while-write-groonga.svg
  # relative_height = 95

= PGroongaと更新と参照

  # image
  # src = images/read-while-write-pgroonga.svg
  # relative_height = 95

= 参照ロックフリーの実現

  # image
  # src = images/reference-lock-free-idea.svg
  # relative_height = 100

= amindexでのポイント

  * (({Lock*()}))(('note:(*)'))を呼ばない\n
    (('note:(*) PostgreSQL提供のロックAPI'))
    * 呼ぶとGroongaの参照ロックフリーの有意性を殺してしまう

= 本格的な例3

(('tag:center'))
継続的な更新に強い

この特徴が有用なサービス例：

  * SNS
    * イメージ：Twitter・Facebook
  * チャット
    * イメージ：Slack

= 継続的な更新に強い？

  * 間欠的な性能劣化がない
    * 更新も検索も
  * GINは両方ある
    * (({FASTUPDATE}))を無効にしていない場合

= 間欠的性能劣化がない理由

  * 常に最新ポスティングリストを\n
    維持しているから
    * 更新負荷が高くならない対策入り\n
      (('note:https://github.com/groonga/groonga/wiki/Memo'))
  * GINは維持をサボって高速化
    * サボったつけを払うときに性能劣化
    * 例：検索時・更新が溜まりすぎた時

= 本格的な例4

(('tag:center'))
索引の作り直しが速い

この特徴が有用なケース：

  * ダンプのリストア
  * サービス復旧

= 速い理由

静的索引構築を\n
サポート

= 索引構築方法

  * 動的
    * 計算量：O(n(('sup:2')))
    * 構築中も完了した分は検索可能
  * 静的
    * 計算量：O(n)
    * 構築完了まで使えないが速い

(('note:n:文書数'))

= 索引構築

  # RT
  delimiter = [|]

  元データの\nロード時間 | 索引\n構築時間

  16分31秒 | 25分37秒

(('tag:center'))
データ：Wikipedia日本語版

= 索引構築：比較

  # RT
  delimiter = [|]

  PGroonga | pg_bigm

  25分37秒 | 5時間56分15秒

(('tag:center'))
pg_bigmより約14倍速い！

= SQL

  # coderay sql
  -- 動的
  CREATE INDEX ...;
  INSERT ...;
  -- 静的
  INSERT ...;
  CREATE INDEX ...;

= amindexでのポイント

  * (({aminsert()}))で\n
    動的インデックス構築を実装
  * (({ambuild()}))で\n
    静的インデックス構築を実装

= 速い理由のまとめ

  * 索引だけで検索可能
  * 更新中も検索可能
  * 間欠的な性能劣化なし
  * 索引構築が速い

= xxx


TODO: 図を入れる

  * 完全の検索
    * インデックスで検索→対象文書を特定
  * recheckありの検索
    * インデックスで検索→候補文書の絞り込み
    * 候補文書を全件スキャンして対象文書を特定
    * 文書が長いとスキャンが重い

= 本格的な例3

(('tag:center'))
インデックスの作り直しが速い

この特徴が有用なケース：

  * ダンプのリストア
  * サービス復旧

= 本格的な例4

(('tag:center'))
削除が速い

この特徴が有用なケース：

  * (({VACUUM}))

= 速い理由

TODO: 図を入れる

  * ピンポイントで\n
    ポスティングリストを\n
    更新するから
    * 注：削除対象の文書とIDが必要
  * GINはすべての\n
    ポスティングリストを\n
    スキャンする
    * 注：削除対象の文書IDだけが必要

= amindexでのポイント

  * (({ambulkdelete()}))でctidから\n
    インデックス対象のデータを\n
    参照できるようにする
    * PostgreSQLからは取得できない

= 本格的な例5

(('tag:center'))
長い文書でも検索が速い

この特徴が有用なサービス例：

  * Wiki
    * イメージ：Wikipedia
  * ドキュメント検索
    * イメージ：ファイルサーバー検索

= 長い文書で検索が速い理由

((*完全*))転置\n
インデックス

= 転置インデックス

  * 完全：位置情報あり
    * Groonga
  * 無印：位置情報なし
    * GIN

= 位置情報あり

TODO: 図を入れる

  * 完全の検索
    * インデックスで検索→対象文書を特定
  * recheckありの検索
    * インデックスで検索→候補文書の絞り込み
    * 候補文書を全件スキャンして対象文書を特定
    * 文書が長いとスキャンが重い

= 本格的な例6

(('tag:center'))
表記のゆらぎを吸収できる

この特徴が有用なサービス例：

  * SNS
  * Wiki
  * ブログ

(('note:不特定多数が記述する文書を検索したいとき'))

= 表記ゆらぎの吸収

  * テキストを正規化
    * ﾎﾟｽｸﾞﾚ→ポスグレ
  * 同義語展開
    * ネジ→ネジ OR ボルト
  * ステミング
    * found/finds→find

